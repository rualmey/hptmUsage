% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calculateUsage.R
\name{calculateUsage}
\alias{calculateUsage}
\alias{calculateUsage,QFeatures-method}
\alias{calculateUsage,SummarizedExperiment-method}
\title{Calculate hPTM Usage}
\usage{
calculateUsage(
  object,
  ...,
  usage_level = c("histone", "histone_family", "histone_group"),
  deconv = "mods_ref",
  sep = ";",
  group = "histone_group"
)

\S4method{calculateUsage}{QFeatures}(
  object,
  i,
  name = "ptm",
  identifier = "feature_number",
  ...,
  usage_level = c("histone", "histone_family", "histone_group"),
  deconv = "mods_ref",
  sep = ";",
  group = "histone_group"
)

\S4method{calculateUsage}{SummarizedExperiment}(
  object,
  ...,
  usage_level = c("histone", "histone_family", "histone_group"),
  deconv = "mods_ref",
  sep = ";",
  group = "histone_group"
)
}
\arguments{
\item{object}{The \code{QFeatures} or \code{SummarizedExperiment} object from which
hPTM usage needs to be calculated.}

\item{...}{Additional arguments passed to \code{\link[QFeatures:QFeatures-aggregate]{QFeatures::aggregateFeatures()}}.}

\item{usage_level}{A \code{character(1)} defining the level at which usage will be
calculated, i.e., what is considered the "parent protein". Must be one of:
\itemize{
\item \code{"histone"} = the total histone abundance (default)
\item \code{"histone_family"} = the total family abundance
\item \code{"histone_group"} = the histone group abundance
}}

\item{deconv}{A \code{character(1)} pointing to the rowData column defining the
features to deconvolute; for example, hPTMs after alignment mapping.}

\item{sep}{The \code{character(1)} used to separate different hPTMs/... in the
\code{deconv} column.}

\item{group}{A \code{character(1)} pointing to the rowData column defining the
level at which deconvolution features (e.g., hPTMs) will be grouped; for
example, the histone family or histone variant group.}

\item{i}{The index (\code{integer()}) or name (\code{character()}) of the assay(s) to
be processed.}

\item{name}{Name(s) of the new assay(s) to add to the QFeatures object. Must
have the same length as i.}

\item{identifier}{A \code{character(1)} naming a rowData variable uniquely
defining the features.}
}
\value{
A \code{QFeatures} with PTM usage assay(s) added or a PTM usage
\code{SummarizedExperiment} (same as supplied).
}
\description{
hPTM usage is calculated by first normalizing histone peptidoforms (i.e.,
subtracting the "parent protein" abundance) and then summarizing to the
hPTM level.
}
\examples{
\dontrun{
# By default, the entire chromatosome abundance (i.e., aggregated value of
# all histone features) is used as normalization factor
new_qf <- hptm_benchmark |>
  calculateUsage(i = "precursorHistone")
#' # A hPTM will be defined as the unique combination of histone
# group and PTM, e.g., H33K27Me3
rowData(new_qf[["ptm"]])[258, ]
# but if two hPTMs are only quantified from the same features, then these
# will form one "hPTM group".
rowData(new_qf[["ptm"]])[257, ]

# It is also possible to correct for the histone family abundance
new_qf <- new_qf |>
  calculateUsage(i = "precursorHistone", name = "ptm_family", usage_level = "histone_family") |>
# or to do a "variant-corrected" analysis
  calculateUsage(i = "precursorHistone", name = "ptm_group", usage_level = "histone_group")

# The default aggregation function (`MsCoreUtils::robustSummary()`) can be
# slow if feature groups are large, for example when `usage_level = "histone`
# In this case, it can be faster to use `MsCoreUtils::medianPolish()` instead
new_qf_mp <- hptm_benchmark |>
  calculateUsage(
    i = "precursorHistone",
    fun = MsCoreUtils::medianPolish,
    na.rm = TRUE
  )

# Finally, if the unaligned amino acid index is to be used instead
new_qf_unaligned <- hptm_benchmark |>
  calculateUsage(i = "precursorHistone", deconv = "mods_var")
}
\dontrun{
# By default, the entire chromatosome abundance (i.e., aggregated value of
# all histone features) is used as normalization factor
new_se <- hptm_benchmark[[5]] |>
  calculateUsage()
# A hPTM will be defined as the unique combination of histone
# group and PTM, e.g., H33K27Unmod
rowData(new_se)[258, ]
# but if two hPTMs are only quantified from the same features, then these
# will form one "hPTM group".
rowData(new_se)[257, ]

# It is also possible to correct for the histone family abundance
new_se_hf <- hptm_benchmark[[5]] |>
  calculateUsage(usage_level = "histone_family")
# or to do a "variant-corrected" analysis
new_se_vc <- hptm_benchmark[[5]] |>
  calculateUsage(usage_level = "histone_group")

# The default aggregation function (`MsCoreUtils::robustSummary()`) can be
# slow if feature groups are large, for example when `usage_level = "histone`
# In this case, it can be faster to use `MsCoreUtils::medianPolish()` instead
new_se_mp <- hptm_benchmark[[5]] |>
  calculateUsage(fun = MsCoreUtils::medianPolish, na.rm = TRUE)

# Finally, if the unaligned amino acid index is to be used instead
new_se_unaligned <- hptm_benchmark[[5]] |>
  calculateUsage(deconv = "mods_var")
}
}
\references{
(1) Demeulemeester N, GÃ©belin M, Gomes LC, Lingor P, Carapito C, Martens L,
Clement L. msqrob2PTM: Differential Abundance and Differential Usage Analysis
of MS-Based Proteomics Data at the Posttranslational Modification and
Peptidoform Level. Molecular & Cellular Proteomics. 2024 Feb 1;23(2):100708.
\url{https://pubs.acs.org/doi/full/10.1021/acs.jproteome.2c00145}.
}
