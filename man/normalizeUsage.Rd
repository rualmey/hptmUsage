% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/normalizeUsage.R
\name{normalizeUsage}
\alias{normalizeUsage}
\alias{normalizeUsage,QFeatures-method}
\alias{normalizeUsage,SummarizedExperiment-method}
\title{Usage Normalization of hPTMs}
\usage{
normalizeUsage(
  object,
  ...,
  usage_level = c("histone", "histone_family", "histone_group")
)

\S4method{normalizeUsage}{QFeatures}(
  object,
  i,
  name = "precursorNorm",
  ...,
  usage_level = c("histone", "histone_family", "histone_group")
)

\S4method{normalizeUsage}{SummarizedExperiment}(
  object,
  ...,
  usage_level = c("histone", "histone_family", "histone_group")
)
}
\arguments{
\item{object}{The \code{QFeatures} or \code{SummarizedExperiment} object to be
usage normalized.}

\item{...}{Additional arguments passed to \code{\link[QFeatures:QFeatures-aggregate]{QFeatures::aggregateFeatures()}}.}

\item{usage_level}{A \code{character(1)} defining the level at which usage will be
calculated, i.e., what is considered the "parent protein". Must be one of:
\itemize{
\item \code{"histone"} = the total histone abundance (default)
\item \code{"histone_family"} = the total family abundance
\item \code{"histone_group"} = the histone group abundance
}}

\item{i}{The index (\code{integer()}) or name (\code{character()}) of the assay(s) to
be processed.}

\item{name}{Name(s) of the new assay(s) to add to the QFeatures object. Must
have the same length as i.}
}
\value{
A \code{QFeatures} with usage normalized assay(s) added or a deconvoluted
\code{SummarizedExperiment} (same as supplied).
}
\description{
This is primarily an internal function required before usage aggregation.
}
\details{
Histone precursors are normalized by subtracting the parent protein abundance
from the (globally normalized) feature abundances. See also Demeulemeester et
al. (1).
}
\examples{
\dontrun{
# By default, the entire chromatosome abundance (i.e., aggregated value of
# all histone features) is used as normalization factor
new_qf <- hptm_benchmark |>
  normalizeUsage(i = "precursorHistone")
# It is also possible to to correct for the histone family abundance
new_qf_hf <- hptm_benchmark |>
  normalizeUsage(i = "precursorHistone", usage_level = "histone_family")
# or to do a "variant-corrected" analysis
new_qf_vc <- hptm_benchmark |>
  normalizeUsage(i = "precursorHistone", usage_level = "histone_group")

# The default aggregation function (`MsCoreUtils::robustSummary()`) can be
# slow if feature groups are large, for example when `usage_level = "histone`
# In this case, it can be faster to use `MsCoreUtils::medianPolish()` instead
new_qf_mp <- hptm_benchmark |>
  normalizeUsage(
    i = "precursorHistone",
    fun = MsCoreUtils::medianPolish,
    na.rm = TRUE
  )
}
\dontrun{
# By default, the entire chromatosome abundance (i.e., aggregated value of
# all histone features) is used as normalization factor
new_se <- hptm_benchmark[[5]] |>
  normalizeUsage()
# It is also possible to to correct for the histone family abundance
new_se_hf <- hptm_benchmark[[5]] |>
  normalizeUsage(usage_level = "histone_family")
# or to do a "variant-corrected" analysis
new_se_vc <- hptm_benchmark[[5]] |>
  normalizeUsage(usage_level = "histone_group")

# The default aggregation function (`MsCoreUtils::robustSummary()`) can be
# slow if feature groups are large, for example when `usage_level = "histone`
# In this case, it can be faster to use `MsCoreUtils::medianPolish()` instead
new_se_mp <- hptm_benchmark[[5]] |>
  normalizeUsage(fun = MsCoreUtils::medianPolish, na.rm = TRUE)
}
}
\references{
(1) Demeulemeester N, GÃ©belin M, Gomes LC, Lingor P, Carapito C, Martens L,
Clement L. msqrob2PTM: Differential Abundance and Differential Usage Analysis
of MS-Based Proteomics Data at the Posttranslational Modification and
Peptidoform Level. Molecular & Cellular Proteomics. 2024 Feb 1;23(2):100708.
\url{https://pubs.acs.org/doi/full/10.1021/acs.jproteome.2c00145}.
}
