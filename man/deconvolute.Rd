% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/deconvolute.R
\name{deconvolute}
\alias{deconvolute}
\alias{deconvolute,QFeatures-method}
\alias{deconvolute,SummarizedExperiment-method}
\title{Deconvolute (hPTM) Features}
\usage{
deconvolute(
  object,
  ...,
  deconv = "mods_ref",
  sep = ";",
  group = "histone_group"
)

\S4method{deconvolute}{QFeatures}(
  object,
  i,
  name = "precursorDeconv",
  identifier = "feature_number",
  deconv = "mods_ref",
  sep = ";",
  group = "histone_group"
)

\S4method{deconvolute}{SummarizedExperiment}(object, deconv = "mods_ref", sep = ";", group = "histone_group")
}
\arguments{
\item{object}{The \code{QFeatures} or \code{SummarizedExperiment} object to be
deconvoluted.}

\item{...}{Additional arguments passed to specific methods.}

\item{deconv}{A \code{character(1)} pointing to the rowData column defining the
features to deconvolute; for example, hPTMs after alignment mapping.}

\item{sep}{The \code{character(1)} used to separate different hPTMs/... in the
\code{deconv} column.}

\item{group}{Optional, a \code{character(1)} pointing to the rowData column
defining the level at which deconvolution features (e.g., hPTMs) will be
grouped; for example, the histone family or histone variant group.}

\item{i}{The index (\code{integer()}) or name (\code{character()}) of the assay(s) to
be processed.}

\item{name}{Name(s) of the new assay(s) to add to the QFeatures object. Must
have the same length as i.}

\item{identifier}{A \code{character(1)} naming a rowData variable uniquely
defining the features.}
}
\value{
A \code{QFeatures} with deconvoluted assay(s) added or a deconvoluted
\code{SummarizedExperiment} (same as supplied).
}
\description{
This is primarily an internal function required before usage aggregation and
normalization.
}
\details{
One feature can contain multiple hPTMs. Such features will be replicated and
assigned one hPTM each. This is needed to be able to use \code{\link[=calculateUsage]{calculateUsage()}},
which relies on \code{\link[QFeatures:QFeatures-aggregate]{QFeatures::aggregateFeatures()}}.

Different hPTMs can have the same underlying information. These "degenerate"
PTMs cannot be discerned from one another, so they are added into "hPTM
groups".
}
\examples{
new_qf <- hptm_benchmark |>
  deconvolute(i = "precursor")
# By default, a hPTM will be defined as the unique combination of histone
# group and PTM, e.g., H33K27Me3
rowData(new_qf[["precursorDeconv"]])[938, ]
# but if two hPTMs are only quantified from the same features, then these
# will form one "hPTM group".
rowData(new_qf[["precursorDeconv"]])[910, ]
# and if the unaligned amino acid index is to be used instead
new_qf_unaligned <- hptm_benchmark |>
  deconvolute(i = "precursor", deconv = "mods_var")
new_se <- hptm_benchmark[[2]] |>
  deconvolute()
# By default, a hPTM will be defined as the unique combination of histone
# group and PTM, e.g., H33K27Me3
rowData(new_se)[938, ]
# but if two hPTMs are only quantified from the same features, then these
# will form one "hPTM group".
rowData(new_se)[910, ]
# and if the unaligned amino acid index is to be used instead
new_se_unaligned <- hptm_benchmark[[2]] |>
  deconvolute(deconv = "mods_var")
}
